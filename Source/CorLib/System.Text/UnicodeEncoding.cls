VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 1  'Persistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "UnicodeEncoding"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
'The MIT License (MIT)
'Copyright (c) 2012 Kelly Ethridge
'
'Permission is hereby granted, free of charge, to any person obtaining a copy
'of this software and associated documentation files (the "Software"), to deal
'in the Software without restriction, including without limitation the rights to
'use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
'the Software, and to permit persons to whom the Software is furnished to do so,
'subject to the following conditions:
'
'The above copyright notice and this permission notice shall be included in all
'copies or substantial portions of the Software.
'
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
'INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
'PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
'FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
'OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
'DEALINGS IN THE SOFTWARE.
'
'
' Module: UnicodeEncoding
'

''
' A set of functions used to convert UTF-16 Unicode characters to and from byte arrays.
'
' @remarks <p>This encoding can encode characters using big-endian or little-endian
' notation. The default is little-endian (least significant byte first).</p>
' <p>A Byte order Mark will be emitted if selected using the <a href="Constructors.NewUnicodeEncoding.html">Cor.NewUnicodeEncoding</a> constructor.</p>
'
' @see Constructors
' @see Encoding
'
Option Explicit
Implements IObject
Implements Encoding
Implements ICloneable

Private Const IsReadOnlyProp            As String = "IsReadOnly"
Private Const IsBigEndianProp           As String = "IsBigEndian"
Private Const EmitBOMProp               As String = "EmitBOM"
Private Const CodePageProp              As String = "CodePage"
Private Const DecoderFallbackProp       As String = "DecoderFallback"
Private Const EncoderFallbackProp       As String = "EncoderFallback"

Private mIsReadOnly         As Boolean
Private mIsBigEndian        As Boolean
Private mEmitBOM            As Boolean
Private mCodePage           As Long
Private mDecoderFallback    As DecoderFallback
Private mEncoderFallback    As EncoderFallback
Private mSingleByte(0)      As Byte
Private mDoubleByte(0 To 1) As Byte
Private mLongCharsSA        As SafeArray1d
Private mLongBytesSA        As SafeArray1d
Private mLongCharsSAPtr     As Long
Private mLongBytesSAPtr     As Long


''
' When implemented in a derived class, gets a value indicating whether the current encoding is read-only.
'
' @return <b>true</b> if the current <a href="Encoding.html">Encoding</a> is read-only; otherwise, <b>false</b>. The default is <b>true</b>.
'
Public Property Get IsReadOnly() As Boolean
    IsReadOnly = mIsReadOnly
End Property

''
' Creates a clone of the current Encoding instance.
'
' @return A cloned instance of a UnicodeEncoding object.
' @remarks A cloned instance will have the read-only limitations removed.
'
Public Function Clone() As UnicodeEncoding
    Set Clone = New UnicodeEncoding
    Clone.InitClone Me
End Function

''
' Gets if the current encoding uses single-byte code points.
'
' @return Returns True for single-byte, False for multi-byte code points.
Public Property Get IsSingleByte() As Boolean
    IsSingleByte = False
End Property

''
' Gets the encoding name to be used in with the mail agent body tags.
'
' @return The body tag compatible encoding name.
'
Public Property Get BodyName() As String
    BodyName = Table.BodyName(CodePage)
End Property

''
' Gets the code page identifier for this encoding.
'
' @return Code page identifier.
'
Public Property Get CodePage() As Long
    CodePage = mCodePage
End Property

''
' Gets the name of this encoding.
'
' @return The encoding's name.
'
Public Property Get EncodingName() As String
    EncodingName = Table.EncodingName(CodePage)
End Property

''
' Gets the encoding name to be used in with the mail agent header tags.
'
' @return The header tag compatible encoding name.
'
Public Property Get HeaderName() As String
    HeaderName = Table.HeaderName(CodePage)
End Property

''
' Gets if this encoding can be used by browsers to display text.
'
' @return The indication for browser display capable.
'
Public Property Get IsBrowserDisplay() As Boolean
    IsBrowserDisplay = Table.IsBrowserDisplay(CodePage)
End Property

''
' Gets if this encoding can be used to save data with this encoding.
'
' @return The indication for the browser saving capable.
'
Public Property Get IsBrowserSave() As Boolean
    IsBrowserSave = Table.IsBrowserSave(CodePage)
End Property

''
' Gets if this encoding can be used to display mail and news by
' mail and news clients.
'
' @return Indication for mail and news client capable.
'
Public Property Get IsMailNewsDisplay() As Boolean
    IsMailNewsDisplay = Table.IsMailNewsDisplay(CodePage)
End Property

''
' Gets if this encoding can be used to save date by mail and news clients.
'
' @return Indication for the mail and news clients to use this encoding for saving.
'
Public Property Get IsMailNewsSave() As Boolean
    IsMailNewsSave = Table.IsMailNewsSave(CodePage)
End Property

''
' Gets the encoding name registered with the Internet Assigned Numbers Authority.
'
' @return The registered encoding name.
'
Public Property Get WebName() As String
    WebName = Table.WebName(CodePage)
End Property

''
' Gets the Windows Operating System's code page for this encoding.
'
' @return The Windows code page for this encoding.
'
Public Property Get WindowsCodePage() As Long
    WindowsCodePage = Table.WindowsCodePage(CodePage)
End Property

''
' Gets the current DecoderFallback instance used by the encoding.
'
' @return An object derived from <a href="DecoderFallback.html">DecoderFallback</a>.
' @remarks The default will return an instance of <a href="DecoderReplacementFallback.html">DecoderReplacementFallback</a>.
'
Public Property Get DecoderFallback() As DecoderFallback
    Set DecoderFallback = mDecoderFallback
End Property

''
' Sets the <a href="DecoderFallback.html">DecoderFallback</a> to be used by this encoding instance.
'
' @param Value The <a href="DecoderFallback.html">DecoderFallback</a> instance to set.
' @remarks By default an <a href="Encoding">Encoding</a> instance is marked as read-only and setting
' this value will result in an <a href="InvalidOperationException.html">InvalidOperationException</a>
' being thrown. If a clone of the instance is made, then it will become read-write and allow the
' setting of the value.
'
Public Property Set DecoderFallback(ByVal Value As DecoderFallback)
    If mIsReadOnly Then _
        Error.InvalidOperation InvalidOperation_ReadOnly
    If Value Is Nothing Then _
        Error.ArgumentNull "Value"
    
    Set mDecoderFallback = Value
End Property

''
' Gets the current EncoderFallback instance used by the encoding.
'
' @return An object derived from <a href="EncoderFallback.html">EncoderFallback</a>.
' @remarks The default will return an instance of <a href="EncoderReplacementFallback.html">EncoderReplacementFallback</a>.
'
Public Property Get EncoderFallback() As EncoderFallback
    Set EncoderFallback = mEncoderFallback
End Property

''
' Sets the <a href="EncoderFallback.html">EncoderFallback</a> to be used by this encoding instance.
'
' @param Value The <a href="EncoderFallback.html">EncoderFallback</a> instance to set.
' @remarks By default an <a href="Encoding">Encoding</a> instance is marked as read-only and setting
' this value will result in an <a href="InvalidOperationException.html">InvalidOperationException</a>
' being thrown. If a clone of the instance is made, then it will become read-write and allow the
' setting of the value.
'
Public Property Set EncoderFallback(ByVal Value As EncoderFallback)
    If mIsReadOnly Then _
        Error.InvalidOperation InvalidOperation_ReadOnly
    If Value Is Nothing Then _
        Error.ArgumentNull "Value"
    
    Set mEncoderFallback = Value
End Property

''
' Returns the number of bytes that would be produced from the set of characters using this encoding.
'
' @param Chars A set of characters used to calculated the number of bytes once encoded with this encoding.
' @param Index The starting index of the first character to be used.
' @param Count The number of characters to include in the calculation.
' @return The number of bytes that would be produced by encoding the set of characters.
' @remarks The <i>Chars</i> parameter will accept either a String or an Integer array. The Index
' is zero based for both the String and Integer array, not 1 based like Mid$.
'
Public Function GetByteCount(ByRef Chars As Variant, Optional ByRef Index As Variant, Optional ByRef Count As Variant) As Long
    Dim LocalChars()    As Integer
    Dim Range           As ListRange
    
    LocalChars = AsChars(Chars)
    
    On Error GoTo Catch
    Range = ValidateGetBytes(LocalChars, Index, Count)
    GetByteCount = GetByteCountCore(LocalChars, Range.Index, Range.Count, Nothing)
    
    FreeChars LocalChars
    Exit Function
    
Catch:
    FreeChars LocalChars
    ThrowOrErr Err
End Function

''
' Encodes a set of characters into an array of bytes.
'
' @param Chars The set of characters to be encoded into an array of bytes. This can
' be either an Integer array or a String.
' @param Index The index of the first character to begin encoding from.
' @param Count The number of characters to be encoded.
' @return A byte array containing the encoded characters as bytes.
' @remarks The <i>Chars</i> parameter will accept either a String or an Integer array. The Index
' is zero based for both the String and Integer array, not 1 based like Mid$.
'
Public Function GetBytes(ByRef Chars As Variant, Optional ByRef Index As Variant, Optional ByRef Count As Variant) As Byte()
    Dim Range           As ListRange
    Dim LocalChars()    As Integer
    Dim Output()        As Byte
    
    LocalChars = AsChars(Chars)
    
    On Error GoTo Catch
    Range = ValidateGetBytes(LocalChars, Index, Count)
    
    If Range.Count > 0 Then
        ReDim Output(0 To GetByteCountCore(LocalChars, Range.Index, Range.Count, Nothing) - 1)
        GetBytesCore LocalChars, Range.Index, Range.Count, Output, 0, Nothing
    Else
        Output = Cor.NewBytes()
    End If
    
    FreeChars LocalChars
    GetBytes = Output
    Exit Function
    
Catch:
    FreeChars LocalChars
    ThrowOrErr Err
End Function

''
' Encodes a set of characters into an array of bytes, returning the number of bytes produced.
'
' @param Chars the set of characters to be encoded into bytes. This can
' be either an Integer array or a String.
' @param CharIndex The index of the first character to begin encoding from.
' @param CharCount The number of characters to be encoded.
' @param Bytes The destination for the encoded characters.
' @param ByteIndex The index of the first byte stored in the destination array.
' @return The number of bytes produce by the encoding.
' @remarks The <i>Bytes</i> array cannot be null and must be large enough to hold the encoded
' set of characters. To obtain the size required, use <a href="UnicodeEncoding.GetByteCount.html">GetByteCount</a> to find the necessary size.
' Or, use <a href="UnicodeEncoding.GetMaxByteCount.html">GetMaxByteCount</a> to get the largest size that could be produced. The largest size is not
' the perfect size, only the maximum number of bytes that could ever be produced by a number of
' characters. Resizing of the resultant <i>Bytes</i> array may be necessary.
'
Public Function GetBytesEx(ByRef Chars As Variant, ByVal CharIndex As Long, ByVal CharCount As Long, ByRef Bytes() As Byte, ByVal ByteIndex As Long) As Long
    Dim LocalChars() As Integer
    
    LocalChars = AsChars(Chars)
    
    On Error GoTo Catch
    ValidateGetBytesEx LocalChars, CharIndex, CharCount, Bytes, ByteIndex
    
    If CharCount > 0 Then
        GetBytesEx = GetBytesCore(LocalChars, CharIndex, CharCount, Bytes, ByteIndex, Nothing)
    End If
    
    FreeChars LocalChars
    Exit Function
    
Catch:
    FreeChars LocalChars
    ThrowOrErr Err
End Function

''
' Returns the number of characters that would be produced by decoding a byte array.
'
' @param Bytes The bytes to use when calculating the number of characters.
' @param Index The starting index in <i>Bytes</i> to being calculating from.
' @param Count The number of bytes to be used in the calculation.
' @return The number of characters that would be decoded from the set of bytes.
'
Public Function GetCharCount(ByRef Bytes() As Byte, Optional ByRef Index As Variant, Optional ByRef Count As Variant) As Long
    Dim Range As ListRange
    
    Range = ValidateGetChars(Bytes, Index, Count)
    
    If Range.Count > 0 Then
        GetCharCount = GetCharCountCore(Bytes, Range.Index, Range.Count, Nothing)
    End If
End Function

''
' Decodes a set of bytes into a set of characters.
'
' @param Bytes The set of bytes to be decoded into characters.
' @param Index The index of the first byte to be used in decoding.
' @param Count The number of bytes to be used in decoding.
' @return An array of characters decoded from the set of bytes.
'
Public Function GetChars(ByRef Bytes() As Byte, Optional ByRef Index As Variant, Optional ByRef Count As Variant) As Integer()
    Dim Range       As ListRange
    Dim Output()    As Integer
    
    Range = ValidateGetChars(Bytes, Index, Count)
    
    If Range.Count > 0 Then
        ReDim Output(0 To GetCharCountCore(Bytes, Range.Index, Range.Count, Nothing) - 1)
        GetCharsCore Bytes, Range.Index, Range.Count, Output, 0, Nothing
    Else
        Output = Cor.NewIntegers()
    End If
        
    GetChars = Output
End Function

''
' Decodes a set of bytes into the supplied Integer array.
'
' @param Bytes The set of bytes to be decoded into characters.
' @param ByteIndex The index of the first byte to begin decoding from.
' @param ByteCount The number of bytes to be used in decoding.
' @param Chars The destination character array for the decoded bytes.
' @param CharIndex The first index to begin storing decoded bytes in <i>Chars</i>.
' @return The number of characters decoded from the array of bytes.
' @remarks The <i>Chars</i> array must be large enough to handle all the bytes that will
' be decoded. To ensure the <i>Chars</i> array is large enough, use either GetCharCount or
' GetMaxCharCount to determine a size that will hold the decoded bytes.
'
Public Function GetCharsEx(ByRef Bytes() As Byte, ByVal ByteIndex As Long, ByVal ByteCount As Long, ByRef Chars() As Integer, ByVal CharIndex As Long) As Long
    ValidateGetCharsEx Bytes, ByteIndex, ByteCount, Chars, CharIndex
    
    If ByteCount > 0 Then
        GetCharsEx = GetCharsCore(Bytes, ByteIndex, ByteCount, Chars, CharIndex, Nothing)
    End If
End Function

''
' Returns the maximum number of bytes that can be created from a specific number of characters.
'
' @param CharCount The number of characters to be encoded.
' @return The maximum number of bytes that can be generated from the specified number of characters.
'
Public Function GetMaxByteCount(ByVal CharCount As Long) As Long
    Dim ByteCount As Currency
    
    If CharCount < 0 Then _
        Error.ArgumentOutOfRange "CharCount", ArgumentOutOfRange_NeedNonNegNum
    
    ByteCount = CharCount + 1@
    
    ' A fallback could have a count of zero meaning we could create
    ' a zero length buffer, even if the fallback is never needed.
    ' So do a check here first.
    If mEncoderFallback.MaxCharCount > 1 Then
        ByteCount = ByteCount * mEncoderFallback.MaxCharCount
    End If
    
    ByteCount = ByteCount * 2
    
    If ByteCount > &H7FFFFFFF Then _
        Error.ArgumentOutOfRange "CharCount", ArgumentOutOfRange_GetByteCountOverflow
        
    GetMaxByteCount = ByteCount
End Function

''
' Returns the maximum number of characters than can be decoded from the number of bytes specified.
'
' @param ByteCount The number of bytes to be decoded.
' @return The maximum number of characters that can be decoded from the specified number of bytes.
'
Public Function GetMaxCharCount(ByVal ByteCount As Long) As Long
    Dim CharCount As Currency
    
    If ByteCount < 0 Then _
        Error.ArgumentOutOfRange "ByteCount", ArgumentOutOfRange_NeedNonNegNum

    CharCount = CCur(CLng(ByteCount \ 2)) + (ByteCount And 1) + 1
    
    If mDecoderFallback.MaxCharCount > 1 Then
        CharCount = CharCount * mDecoderFallback.MaxCharCount
    End If
    
    If CharCount > &H7FFFFFFF Then _
        Error.ArgumentOutOfRange "ByteCount", ArgumentOutOfRange_GetCharCountOverflow
        
    GetMaxCharCount = CharCount
End Function

''
' Returns an array of bytes that represents this encoding.
'
' @return A byte array containg the bytes to be used to identify this encoding type.
' @remarks <p>If the encoding was created setting the <a href="Constructors.NewUnicodeEncoding.html">BigEndian</a> paramter
' to true, then this will return the Unicode byte array identifer &HFEFF otherwise
' &hFFFE for a non-bigEndian encoding. If no identifier is to be emitted, then an
' empty byte array is returned (not a null array).
'
Public Function GetPreamble() As Byte()
    If mEmitBOM Then
        If mIsBigEndian Then
            GetPreamble = Cor.NewBytes(&HFE, &HFF)
        Else
            GetPreamble = Cor.NewBytes(&HFF, &HFE)
        End If
    Else
        GetPreamble = Cor.NewBytes()
    End If
End Function

''
' Decodes a set of bytes into a String.
'
' @param Bytes The set of bytes to be decoded into a string.
' @param Index The index of the first byte to be decoded.
' @param Count The number of bytes to be used in the decoding.
' @return A string containing the decoded set of bytes.
'
Public Function GetString(ByRef Bytes() As Byte, Optional ByRef Index As Variant, Optional ByRef Count As Variant) As String
    Dim Range   As ListRange
    Dim Chars() As Integer
    
    Range = ValidateGetChars(Bytes, Index, Count)
    GetString = SysAllocStringLen(0, GetCharCountCore(Bytes, Range.Index, Range.Count, Nothing))
    Chars = AllocChars(GetString)
    
    On Error GoTo Catch
    GetCharsCore Bytes, Range.Index, Range.Count, Chars, 0, Nothing
    
    FreeChars Chars
    Exit Function
    
Catch:
    FreeChars Chars
    ThrowOrErr Err
End Function

''
' Returns an encoder that maintains state.
'
' @return The stateful encoder.
' @remarks Since encoding Unicode characters equates to exactly 2 bytes per
' character, there is no state that is maintained between calls. This method
' functions identically to GetBytes.
'
Public Function GetEncoder() As Encoder
    Dim Encoder As New UnicodeEncoder
    Encoder.Init Me
    Set GetEncoder = Encoder
End Function

''
' Returns a decoder that maintains state.
'
' @return The stateful decoder.
' @remarks Unlike <b>UnicodeEncoding</b>, the decoder maintains state between decoding calls.
' Since a single unicode character required exactly 2 bytes to be decoded, it is possible
' that an odd number of bytes may be attempted to be decoding, creating an orphaned byte
' which represents only half of a unicode character. The remaining byte is held until
' the next decoding call, and the byte is then inserted at the beginning of the next set
' of bytes to be decoded, picking up byte decoding where the orphaned byte left off.
'
Public Function GetDecoder() As Decoder
    Dim Decoder As New UnicodeDecoder
    Decoder.Init Me
    Set GetDecoder = Decoder
End Function

''
' Returns a string representation of this object instance.
'
' @return String representing this instance.
'
Public Function ToString() As String
    ToString = MyBase.ToString(Me, App)
End Function

''
' Returns a boolean indicating if the value and this object
' instance are the same instance.
'
' @param value The value to compare equality to.
' @return Boolean indicating equality.
'
Public Function Equals(ByRef Value As Variant) As Boolean
    Dim Other As UnicodeEncoding
    
    On Error GoTo Catch
    Set Other = Value
    Equals = CodePage = Other.CodePage And _
             mIsBigEndian = Other.IsBigEndian And _
             mEmitBOM = Other.EmitByteOrderMark And _
             mEncoderFallback.Equals(Other.EncoderFallback) And _
             mDecoderFallback.Equals(Other.DecoderFallback)
    
Catch:
End Function

''
' Returns a pseudo-unique number identifying this instance.
'
' @return Pseudo-unique number identifying this instance.
'
Public Function GetHashCode() As Long
    GetHashCode = mCodePage

    If mIsBigEndian Then
        GetHashCode = GetHashCode Or &H80000000
    End If
    
    If mEmitBOM Then
        GetHashCode = GetHashCode Or &H40000000
    End If
    
    GetHashCode = GetHashCode Xor mEncoderFallback.GetHashCode Xor mDecoderFallback.GetHashCode
End Function


Friend Property Get IsBigEndian() As Boolean
    IsBigEndian = mIsBigEndian
End Property

Friend Property Get EmitByteOrderMark() As Boolean
    EmitByteOrderMark = mEmitBOM
End Property


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   Constructors
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Friend Sub Init(ByVal BigEndian As Boolean, ByVal ByteOrderMark As Boolean, ByVal ThrowOnInvalidBytes As Boolean)
    mIsBigEndian = BigEndian
    mEmitBOM = ByteOrderMark
    
    If BigEndian Then
        mCodePage = 1201
    End If
    
    If ThrowOnInvalidBytes Then
        Set mDecoderFallback = Statics.DecoderFallback.ExceptionFallback
        Set mEncoderFallback = Statics.EncoderFallback.ExceptionFallback
    End If
End Sub

Friend Sub InitClone(ByVal Other As UnicodeEncoding)
    Set mDecoderFallback = Other.DecoderFallback
    Set mEncoderFallback = Other.EncoderFallback
    mCodePage = Other.CodePage
    mIsBigEndian = Other.IsBigEndian
    mEmitBOM = Other.EmitByteOrderMark
    mIsReadOnly = False
End Sub

Private Sub Class_Initialize()
    mLongCharsSA.cbElements = 4
    mLongCharsSA.cDims = 1
    mLongCharsSA.cElements = &H7FFFFFFF
    mLongBytesSA.cbElements = 4
    mLongBytesSA.cDims = 1
    mLongBytesSA.cElements = &H7FFFFFFF
    
    mLongCharsSAPtr = VarPtr(mLongCharsSA)
    mLongBytesSAPtr = VarPtr(mLongBytesSA)
End Sub

Private Sub Class_InitProperties()
    Set mDecoderFallback = Cor.NewDecoderReplacementFallback(ChrW$(&HFFFD))
    Set mEncoderFallback = Cor.NewEncoderReplacementFallback(ChrW$(&HFFFD))
    mCodePage = 1200
    mIsReadOnly = True
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   Helpers
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Friend Property Get Table() As EncodingTable
    Set Table = Statics.Encoding.EncodingTable
End Property

Friend Function GetBytesCore(ByRef Chars() As Integer, ByVal CharIndex As Long, ByVal CharCount As Long, ByRef Bytes() As Byte, ByVal ByteIndex As Long, ByVal Encoder As UnicodeEncoder) As Long
    Dim Ch              As Long
    Dim ByteStart       As Long
    Dim MaxByteIndex    As Long
    Dim PrevChar        As Long
    Dim Fallback        As EncoderFallbackBuffer
    Dim MaxCharIndex    As Long
    Dim LongChars()     As Long
    Dim LongBytes()     As Long
    Dim MaxLongIndex    As Long
    Dim LongIndex       As Long
    Dim LongChar        As Long
    Dim CanFastLoop     As Boolean
    Dim CharsAddress    As Long
    Dim BytesAddress    As Long
    Dim CharsLB         As Long
    Dim BytesLB         As Long
    
    If CharCount = 0 Then
        Exit Function
    End If
    
    If Not Encoder Is Nothing Then
        PrevChar = Encoder.LastChar
        Encoder.LastChar = 0
    End If
    
    CanFastLoop = Not mIsBigEndian And Len1D(Bytes) > 0 And Len1D(Chars) > 0
    
    If CanFastLoop Then
        CharsLB = LBound(Chars)
        BytesLB = LBound(Bytes)
        CharsAddress = VarPtr(Chars(CharsLB))
        BytesAddress = VarPtr(Bytes(BytesLB))
    End If
    
    ByteStart = ByteIndex
    MaxByteIndex = UBound(Bytes)
    MaxCharIndex = CharIndex + CharCount - 1
    
    Do While CharCount > 0
        ' The fast loop was shamefully adapted from the .NET reference source in UnicodeEncoding class.
        If PrevChar = 0 And CanFastLoop Then
            ' do fast looping
            If (MaxByteIndex - ByteIndex + 1) \ 2 < (MaxCharIndex - CharIndex + 1) Then
                MaxLongIndex = (MaxByteIndex - ByteIndex + 1) \ 4 - 1
            Else
                MaxLongIndex = (MaxCharIndex - CharIndex + 1) \ 2 - 1
            End If

            mLongCharsSA.PVData = CharsAddress + (CharIndex - CharsLB) * 2
            mLongBytesSA.PVData = BytesAddress + ByteIndex - BytesLB
            
            SAPtr(LongChars) = mLongCharsSAPtr
            SAPtr(LongBytes) = mLongBytesSAPtr
            
            For LongIndex = 0 To MaxLongIndex
                LongChar = LongChars(LongIndex)
                
                If LongChar And &H80808080 Then
                    Dim Temp As Long
                    
                    Temp = (LongChar And &HF800F800) Xor &HD800D800
                    
                    If (Temp And &HFFFF0000) = 0 Or (Temp And &HFFFF&) = 0 Then
                        If ((LongChar And &HFC00FC00) Xor &HDC00D800) <> 0 Then
                            Exit For
                        End If
                    End If
                End If
                
                LongBytes(LongIndex) = LongChar
            Next
            
            SAPtr(LongChars) = vbNullPtr
            SAPtr(LongBytes) = vbNullPtr
            
            CharIndex = CharIndex + LongIndex * 2
            ByteIndex = ByteIndex + LongIndex * 4
            CharCount = CharCount - LongIndex * 2
            
            If CharCount < 1 Then
                Exit Do
            End If
        End If
        
        Ch = Chars(CharIndex) And &HFFFF&
        
        Select Case Ch
            Case Is < HighSurrogateStart, Is > LowSurrogateEnd
                If PrevChar <> 0 Then
                    ByteIndex = InsertEncoderFallback(PrevChar, CharIndex - 1, Bytes, ByteIndex, Encoder, Fallback)
                    PrevChar = 0
                End If
                
                If ByteIndex + 1 > MaxByteIndex Then _
                    Throw Cor.NewArgumentException(Environment.GetResourceString(Argument_EncodingConversionOverflowBytes, EncodingName, TypeName(EncoderFallback)), "Bytes")
                
                If mIsBigEndian Then
                    Bytes(ByteIndex) = (Ch And &HFF00&) \ vbShift8Bits
                    Bytes(ByteIndex + 1) = Ch And &HFF&
                Else
                    Bytes(ByteIndex) = Ch And &HFF&
                    Bytes(ByteIndex + 1) = (Ch And &HFF00&) \ vbShift8Bits
                End If
                
                ByteIndex = ByteIndex + 2
            Case HighSurrogateStart To HighSurrogateEnd
                If PrevChar <> 0 Then
                    ' we have two high surrogates in a row.
                    ByteIndex = InsertEncoderFallback(PrevChar, CharIndex - 1, Bytes, ByteIndex, Encoder, Fallback)
                End If
                
                PrevChar = Ch
            Case Else
                If PrevChar <> 0 Then
                    ' we have valid surrogate pair.
                    
                    If ByteIndex + 3 > MaxByteIndex Then _
                        Throw Cor.NewArgumentException(Environment.GetResourceString(Argument_EncodingConversionOverflowBytes, EncodingName, TypeName(EncoderFallback)), "Bytes")
                
                    If mIsBigEndian Then
                        Bytes(ByteIndex) = (PrevChar And &HFF00&) \ vbShift8Bits
                        Bytes(ByteIndex + 1) = PrevChar And &HFF&
                        Bytes(ByteIndex + 2) = (Ch And &HFF00&) \ vbShift8Bits
                        Bytes(ByteIndex + 3) = Ch And &HFF&

                    Else
                        Bytes(ByteIndex) = PrevChar And &HFF&
                        Bytes(ByteIndex + 1) = (PrevChar And &HFF00&) \ vbShift8Bits
                        Bytes(ByteIndex + 2) = Ch And &HFF&
                        Bytes(ByteIndex + 3) = (Ch And &HFF00&) \ vbShift8Bits
                    End If
                                
                    ByteIndex = ByteIndex + 4
                    PrevChar = 0
                Else
                    ' low surrogate without previous high surrogate.
                    ByteIndex = InsertEncoderFallback(Ch, CharIndex, Bytes, ByteIndex, Encoder, Fallback)
                End If
        End Select
        
        CharIndex = CharIndex + 1
        CharCount = CharCount - 1
    Loop
    
    If Encoder Is Nothing Then
        If PrevChar <> 0 Then
            ' we have a hanging high surrogate
            ByteIndex = InsertEncoderFallback(PrevChar, CharIndex - 1, Bytes, ByteIndex, Encoder, Fallback)
        End If
    ElseIf Encoder.Flushing Then
        If PrevChar <> 0 Then
            ' we have a hanging high surrogate
            ByteIndex = InsertEncoderFallback(PrevChar, CharIndex - 1, Bytes, ByteIndex, Encoder, Fallback)
        End If
    Else
        Encoder.LastChar = PrevChar
    End If
    
    GetBytesCore = ByteIndex - ByteStart
End Function

Private Function InsertEncoderFallback(ByVal Ch As Long, ByVal CharIndex As Long, ByRef Bytes() As Byte, ByVal ByteIndex As Long, ByVal Encoder As UnicodeEncoder, ByRef Fallback As EncoderFallbackBuffer) As Long
    Dim BytesUBound     As Long
    Dim FallbackChar    As Long
    
    If Fallback Is Nothing Then
        If Encoder Is Nothing Then
            Set Fallback = mEncoderFallback.CreateFallbackBuffer
        Else
            Set Fallback = Encoder.FallbackBuffer
        End If
    End If
    
    Fallback.Reset
    
    If Fallback.Fallback(Ch, Index:=CharIndex) Then
        BytesUBound = UBound(Bytes)
        
        Do While Fallback.Remaining > 0
            If ByteIndex + 1 > BytesUBound Then _
                Throw Cor.NewArgumentException(Environment.GetResourceString(Argument_EncodingConversionOverflowBytes, EncodingName, TypeName(EncoderFallback)), "Bytes")
            
            FallbackChar = Fallback.GetNextChar And &HFFFF&
            
            If mIsBigEndian Then
                Bytes(ByteIndex) = (FallbackChar And &HFF00&) \ vbShift8Bits
                Bytes(ByteIndex + 1) = FallbackChar And &HFF&
            Else
                Bytes(ByteIndex) = FallbackChar And &HFF&
                Bytes(ByteIndex + 1) = (FallbackChar And &HFF00&) \ vbShift8Bits
            End If
            
            ByteIndex = ByteIndex + 2
        Loop
        
        InsertEncoderFallback = ByteIndex
    End If
End Function

Friend Function GetCharCountCore(ByRef Bytes() As Byte, ByVal Index As Long, ByVal Count As Long, ByVal Decoder As UnicodeDecoder) As Long
    Dim CharCount       As Long
    Dim LastByte        As Long
    Dim LastChar        As Long
    Dim FallbackBuffer  As DecoderFallbackBuffer
    Dim CanFastLoop     As Boolean
    Dim LongBytes()     As Long
    Dim MaxLongIndex    As Long
    Dim LongIndex       As Long
    Dim LongByte        As Long
    Dim MaxByteIndex    As Long
    Dim BytesAddress    As Long
    
    MaxByteIndex = Index + Count - 1
    
    If Decoder Is Nothing Then
        LastByte = -1
    Else
        LastByte = Decoder.LastByte
        LastChar = Decoder.LastChar
    End If
    
    CanFastLoop = Not mIsBigEndian And Len1D(Bytes) > 0
    
    If CanFastLoop Then
        BytesAddress = VarPtr(Bytes(Index)) - LBound(Bytes)
    End If
    
    Do While Count > 0
        ' The fast loop was shamefully adapted from the .NET reference source in UnicodeEncoding class.
        If LastChar = 0 And LastByte = -1 And CanFastLoop Then
            ' do fast looping
            MaxLongIndex = (MaxByteIndex - Index + 1) \ 4 - 1

            mLongBytesSA.PVData = BytesAddress + Index
            SAPtr(LongBytes) = mLongBytesSAPtr

            For LongIndex = 0 To MaxLongIndex
                LongByte = LongBytes(LongIndex)

                If LongByte And &H80808080 Then
                    Dim Temp As Long

                    Temp = (LongByte And &HF800F800) Xor &HD800D800

                    If (Temp And &HFFFF0000) = 0 Or (Temp And &HFFFF&) = 0 Then
                        If ((LongByte And &HFC00FC00) Xor &HDC00D800) <> 0 Then
                            Exit For
                        End If
                    End If
                End If
            Next

            SAPtr(LongBytes) = vbNullPtr

            CharCount = CharCount + LongIndex * 2
            Index = Index + LongIndex * 4
            Count = Count - LongIndex * 4

            If Count < 1 Then
                Exit Do
            End If
        End If
    
        If LastByte < 0 Then
            LastByte = Bytes(Index)
            Index = Index + 1
        Else
            Dim Ch As Long
            If mIsBigEndian Then
                Ch = (LastByte * vbShift8Bits) Or Bytes(Index)
            Else
                Ch = (Bytes(Index) * vbShift8Bits) Or LastByte
            End If
            
            Index = Index + 1
            LastByte = -1
            
            Select Case Ch
                Case Is < HighSurrogateStart, Is > LowSurrogateEnd
                    If LastChar <> 0 Then
                        ' we have a preceeding high surrogate that was not followed by a low surrogate.
                        CharCount = CharCount + GetDecoderCharFallbackCount(LastChar, Index - vbSizeOfChar, Decoder, FallbackBuffer)
                        LastChar = 0
                    End If

                    CharCount = CharCount + 1
                Case HighSurrogateStart To HighSurrogateEnd
                    If LastChar <> 0 Then
                        ' we have two high surrogates in a row, so add fallback count for
                        ' first surrogate only. We may still have a low surrogate to follow.
                        CharCount = CharCount + GetDecoderCharFallbackCount(LastChar, Index - vbSizeOfChar, Decoder, FallbackBuffer)
                    End If

                    LastChar = Ch
                Case Else
                    If LastChar <> 0 Then
                        ' we have a valid surrogate pair.
                        CharCount = CharCount + 2
                        LastChar = 0
                    Else
                        ' we have a low surrogate with a missing previous high surrogate so add fallback count.
                        CharCount = CharCount + GetDecoderCharFallbackCount(Ch, Index - vbSizeOfChar, Decoder, FallbackBuffer)
                    End If
            End Select
        End If
        
        Count = Count - 1
    Loop
    
    If Decoder Is Nothing Then
        If LastChar <> 0 Then
            CharCount = CharCount + GetDecoderCharFallbackCount(LastChar, Index - vbSizeOfChar, Decoder, FallbackBuffer)
        End If
        If LastByte >= 0 Then
            CharCount = CharCount + GetDecoderByteFallbackCount(LastByte, Index - 1, Decoder, FallbackBuffer)
        End If
    ElseIf Decoder.Flushing Then
        If LastChar <> 0 Then
            CharCount = CharCount + GetDecoderCharFallbackCount(LastChar, Index - vbSizeOfChar, Decoder, FallbackBuffer)
        End If
        If LastByte >= 0 Then
            CharCount = CharCount + GetDecoderByteFallbackCount(LastByte, Index - 1, Decoder, FallbackBuffer)
        End If
    End If
    
    GetCharCountCore = CharCount
End Function

Private Function GetDecoderByteFallbackCount(ByVal Char As Long, ByVal ByteIndex As Long, ByVal Decoder As Decoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    mSingleByte(0) = Char And &HFF&
    GetDecoderByteFallbackCount = GetDecoderFallbackCount(mSingleByte, ByteIndex, Decoder, FallbackBuffer)
End Function

Private Function GetDecoderCharFallbackCount(ByVal Char As Long, ByVal ByteIndex As Long, ByVal Decoder As Decoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    If mIsBigEndian Then
        mDoubleByte(0) = (Char And &HFF00&) \ vbShift8Bits
        mDoubleByte(1) = Char And &HFF&
    Else
        mDoubleByte(0) = Char And &HFF&
        mDoubleByte(1) = (Char And &HFF00&) \ vbShift8Bits
    End If
    
    GetDecoderCharFallbackCount = GetDecoderFallbackCount(mDoubleByte, ByteIndex, Decoder, FallbackBuffer)
End Function

Private Function GetDecoderFallbackCount(ByRef BytesUnknown() As Byte, ByVal ByteIndex As Long, ByVal Decoder As Decoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    If FallbackBuffer Is Nothing Then
        If Decoder Is Nothing Then
            Set FallbackBuffer = mDecoderFallback.CreateFallbackBuffer
        Else
            Set FallbackBuffer = Decoder.FallbackBuffer
        End If
    End If
                
    If FallbackBuffer.Fallback(BytesUnknown, ByteIndex) Then
        GetDecoderFallbackCount = FallbackBuffer.Remaining
        FallbackBuffer.Reset
    End If
End Function

Friend Function GetByteCountCore(ByRef Chars() As Integer, ByVal Index As Long, ByVal Count As Long, ByVal Encoder As UnicodeEncoder) As Long
    Dim ByteCount       As Long
    Dim PrevChar        As Long
    Dim Fallback        As EncoderFallbackBuffer
    Dim MaxCharIndex    As Long
    Dim LongChars()     As Long
    Dim MaxLongIndex    As Long
    Dim LongIndex       As Long
    Dim LongChar        As Long
    Dim CanFastLoop     As Boolean
    Dim CharsAddress    As Long
    Dim CharsLB         As Long
    
    If Not Encoder Is Nothing Then
        PrevChar = Encoder.LastChar
    End If
    
    CanFastLoop = Not mIsBigEndian And Len1D(Chars) > 0
    
    If CanFastLoop Then
        CharsLB = LBound(Chars)
        CharsAddress = VarPtr(Chars(CharsLB))
    End If
    
    MaxCharIndex = Index + Count - 1
    
    Do While Count > 0
        If PrevChar = 0 And CanFastLoop Then
            ' do fast looping
            MaxLongIndex = (MaxCharIndex - Index + 1) \ 2 - 1
            
            mLongCharsSA.PVData = CharsAddress + (Index - CharsLB) * 2
            SAPtr(LongChars) = mLongCharsSAPtr
            
            For LongIndex = 0 To MaxLongIndex
                LongChar = LongChars(LongIndex)
                
                If LongChar And &H80808080 Then
                    Dim Temp As Long
                    
                    Temp = (LongChar And &HF800F800) Xor &HD800D800
                    
                    If (Temp And &HFFFF0000) = 0 Or (Temp And &HFFFF&) = 0 Then
                        If ((LongChar And &HFC00FC00) Xor &HDC00D800) <> 0 Then
                            Exit For
                        End If
                    End If
                End If
            Next
            
            SAPtr(LongChars) = vbNullPtr
            
            Index = Index + LongIndex * 2
            Count = Count - LongIndex * 2
            ByteCount = ByteCount + LongIndex * 4
            
            If Count < 1 Then
                Exit Do
            End If
        End If
        
        Dim Ch As Long
        Ch = Chars(Index) And &HFFFF&
        
        Select Case Ch
            Case Is < HighSurrogateStart, Is > LowSurrogateEnd
                If PrevChar <> 0 Then
                    ' got a previous high surrogate with no low surrogate
                    ByteCount = ByteCount + GetEncoderFallbackCount(PrevChar, Index - 1, Fallback, Encoder)
                    PrevChar = 0
                End If
    
                ByteCount = ByteCount + vbSizeOfChar
            Case HighSurrogateStart To HighSurrogateEnd
                If PrevChar <> 0 Then
                    ' got two high surrogates in a row
                    ByteCount = ByteCount + GetEncoderFallbackCount(PrevChar, Index - 1, Fallback, Encoder)
                End If

                PrevChar = Ch
            Case Else
                If PrevChar <> 0 Then
                    ' got a valid surrogate pair
                    ByteCount = ByteCount + 4
                    PrevChar = 0
                Else
                    ' low surrogate without previous high surrogate
                    ByteCount = ByteCount + GetEncoderFallbackCount(Ch, Index, Fallback, Encoder)
                End If
        End Select
        
        Index = Index + 1
        Count = Count - 1
    Loop
    
    If Encoder Is Nothing Then
        If PrevChar <> 0 Then
            ' we have a hanging high surrogate
            ByteCount = ByteCount + GetEncoderFallbackCount(PrevChar, Index - 1, Fallback, Encoder)
        End If
    ElseIf Encoder.Flushing Then
        If PrevChar <> 0 Then
            ' we have a hanging high surrogate
            ByteCount = ByteCount + GetEncoderFallbackCount(PrevChar, Index - 1, Fallback, Encoder)
        End If
    End If
    
    GetByteCountCore = ByteCount
End Function

Private Function GetEncoderFallbackCount(ByVal Ch As Long, ByVal CharIndex As Long, ByRef Fallback As EncoderFallbackBuffer, ByVal Encoder As Encoder) As Long
    If Fallback Is Nothing Then
        If Encoder Is Nothing Then
            Set Fallback = mEncoderFallback.CreateFallbackBuffer
        Else
            Set Fallback = Encoder.FallbackBuffer
        End If
    End If
    
    Fallback.Reset
    
    If Fallback.Fallback(Ch, Index:=CharIndex) Then
        GetEncoderFallbackCount = Fallback.Remaining * vbSizeOfChar
    End If
End Function

Friend Function GetCharsCore(ByRef Bytes() As Byte, ByVal ByteIndex As Long, ByVal ByteCount As Long, ByRef Chars() As Integer, ByVal CharIndex As Long, ByVal Decoder As UnicodeDecoder) As Long
    Dim CharIndexStart  As Long
    Dim MaxCharIndex    As Long
    Dim LastByte        As Long
    Dim LastChar        As Long
    Dim FallbackBuffer  As DecoderFallbackBuffer
    Dim CanFastLoop     As Boolean
    Dim LongChars()     As Long
    Dim LongBytes()     As Long
    Dim MaxLongIndex    As Long
    Dim LongIndex       As Long
    Dim LongByte        As Long
    Dim MaxByteIndex    As Long
    Dim CharsAddress    As Long
    Dim BytesAddress    As Long
    Dim CharsLB         As Long
    Dim BytesLB         As Long
    
    CharIndexStart = CharIndex
    MaxCharIndex = UBound(Chars)
    MaxByteIndex = ByteIndex + ByteCount - 1
    
    If Decoder Is Nothing Then
        LastByte = -1
    Else
        LastByte = Decoder.GetAndClearLastByte
        LastChar = Decoder.GetAndClearLastChar
    End If
    
    CanFastLoop = Not mIsBigEndian And Len1D(Bytes) > 0 And Len1D(Chars) > 0
    
    If CanFastLoop Then
        CharsLB = LBound(Chars)
        BytesLB = LBound(Bytes)
        CharsAddress = VarPtr(Chars(CharsLB))
        BytesAddress = VarPtr(Bytes(BytesLB))
    End If
    
    Do While ByteCount > 0
        ' The fast loop was shamefully adapted from the .NET reference source in UnicodeEncoding class.
        If LastChar = 0 And LastByte = -1 And CanFastLoop Then
            ' do fast looping
            If (MaxByteIndex - ByteIndex + 1) \ 2 < (MaxCharIndex - CharIndex + 1) Then
                MaxLongIndex = (MaxByteIndex - ByteIndex + 1) \ 4 - 1
            Else
                MaxLongIndex = (MaxCharIndex - CharIndex + 1) \ 2 - 1
            End If

            mLongCharsSA.PVData = CharsAddress + (CharIndex - CharsLB) * 2
            mLongBytesSA.PVData = BytesAddress + ByteIndex - BytesLB

            SAPtr(LongChars) = mLongCharsSAPtr
            SAPtr(LongBytes) = mLongBytesSAPtr

            For LongIndex = 0 To MaxLongIndex
                LongByte = LongBytes(LongIndex)

                ' Does bit logic to determine if valid or invalid surrogate pair exists.
                If LongByte And &H80808080 Then
                    Dim Temp As Long

                    Temp = (LongByte And &HF800F800) Xor &HD800D800

                    If (Temp And &HFFFF0000) = 0 Or (Temp And &HFFFF&) = 0 Then
                        If ((LongByte And &HFC00FC00) Xor &HDC00D800) <> 0 Then
                            Exit For
                        End If
                    End If
                End If

                LongChars(LongIndex) = LongByte
            Next

            SAPtr(LongChars) = vbNullPtr
            SAPtr(LongBytes) = vbNullPtr

            CharIndex = CharIndex + LongIndex * 2
            ByteIndex = ByteIndex + LongIndex * 4
            ByteCount = ByteCount - LongIndex * 4

            If ByteCount < 1 Then
                Exit Do
            End If
        End If
        
        If LastByte < 0 Then
            LastByte = Bytes(ByteIndex)
            ByteIndex = ByteIndex + 1
        Else
            Dim Ch As Long
            If mIsBigEndian Then
                Ch = (LastByte * vbShift8Bits) Or Bytes(ByteIndex)
            Else
                Ch = (Bytes(ByteIndex) * vbShift8Bits) Or LastByte
            End If
            
            ByteIndex = ByteIndex + 1
            LastByte = -1
            
            Select Case Ch
                Case Is < HighSurrogateStart, Is > LowSurrogateEnd
                    If LastChar <> 0 Then
                        ' we have a preceeding high surrogate that was not followed by a low surrogate.
                        CharIndex = InsertDecoderCharFallback(LastChar, ByteIndex - vbSizeOfChar, Chars, CharIndex, Decoder, FallbackBuffer)
                        LastChar = 0
                    End If

                    If CharIndex > MaxCharIndex Then _
                        ThrowDecoderSmallConversionBuffer

#If Release Then
                    Chars(CharIndex) = Ch
#Else
                    Chars(CharIndex) = AsWord(Ch)
#End If
                    CharIndex = CharIndex + 1
                Case HighSurrogateStart To HighSurrogateEnd
                    If LastChar <> 0 Then
                        ' we have preceeding high surrogate followed by this high surrogate.
                        CharIndex = InsertDecoderCharFallback(LastChar, ByteIndex - vbSizeOfChar, Chars, CharIndex, Decoder, FallbackBuffer)
                    End If

                    LastChar = Ch
                Case Else
                    If LastChar <> 0 Then
                        ' we have a valid surrogate pair.
                        If CharIndex > MaxCharIndex Then _
                            ThrowDecoderSmallConversionBuffer

#If Release Then
                        Chars(CharIndex) = LastChar
                        Chars(CharIndex + 1) = Ch
#Else
                        Chars(CharIndex) = AsWord(LastChar)
                        Chars(CharIndex + 1) = AsWord(Ch)
#End If
                        CharIndex = CharIndex + 2
                        LastChar = 0
                    Else
                        ' we have a low surrogate and expected the preceeding character to be a high surrogate.
                        CharIndex = InsertDecoderCharFallback(Ch, ByteIndex - vbSizeOfChar, Chars, CharIndex, Decoder, FallbackBuffer)
                    End If
            End Select
        End If
        
        ByteCount = ByteCount - 1
    Loop
    
    If Decoder Is Nothing Then
        If LastChar <> 0 Then
            ' have an unmatched high surrogate, handle fallback
            CharIndex = InsertDecoderCharFallback(LastChar, ByteIndex - vbSizeOfChar, Chars, CharIndex, Decoder, FallbackBuffer)
        End If
        If LastByte >= 0 Then
            ' have a partial char, handle fallback
            CharIndex = InsertDecoderByteFallback(LastByte, ByteIndex - 1, Chars, CharIndex, Decoder, FallbackBuffer)
        End If
    ElseIf Decoder.Flushing Then
        If LastChar <> 0 Then
            ' have an unmatched high surrogate, handle fallback
            CharIndex = InsertDecoderCharFallback(LastChar, ByteIndex - vbSizeOfChar, Chars, CharIndex, Decoder, FallbackBuffer)
        End If
        If LastByte >= 0 Then
            ' have a partial char, handle fallback
            CharIndex = InsertDecoderByteFallback(LastByte, ByteIndex - 1, Chars, CharIndex, Decoder, FallbackBuffer)
        End If
    Else
        ' save for next round
        Decoder.LastChar = LastChar
        Decoder.LastByte = LastByte
    End If
    
    GetCharsCore = CharIndex - CharIndexStart
End Function

Private Function InsertDecoderByteFallback(ByVal UnknownChar As Long, ByVal ByteIndex As Long, ByRef Chars() As Integer, ByVal CharIndex As Long, ByVal Decoder As UnicodeDecoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    mSingleByte(0) = UnknownChar And &HFF&
    InsertDecoderByteFallback = InsertDecoderFallback(mSingleByte, ByteIndex, Chars, CharIndex, Decoder, FallbackBuffer)
End Function

Private Function InsertDecoderCharFallback(ByVal UnknownChar As Long, ByVal ByteIndex As Long, ByRef Chars() As Integer, ByVal CharIndex As Long, ByVal Decoder As UnicodeDecoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    If mIsBigEndian Then
        mDoubleByte(0) = (UnknownChar And &HFF00&) \ vbShift8Bits
        mDoubleByte(1) = UnknownChar And &HFF&
    Else
        mDoubleByte(0) = UnknownChar And &HFF
        mDoubleByte(1) = (UnknownChar \ vbShift8Bits) And &HFF
    End If
    
    InsertDecoderCharFallback = InsertDecoderFallback(mDoubleByte, ByteIndex, Chars, CharIndex, Decoder, FallbackBuffer)
End Function

Private Function InsertDecoderFallback(ByRef BytesUnknown() As Byte, ByVal ByteIndex As Long, ByRef Chars() As Integer, ByVal CharIndex As Long, ByVal Decoder As Decoder, ByRef FallbackBuffer As DecoderFallbackBuffer) As Long
    Dim CharsUBound As Long
    
    If FallbackBuffer Is Nothing Then
        If Decoder Is Nothing Then
            Set FallbackBuffer = mDecoderFallback.CreateFallbackBuffer
        Else
            Set FallbackBuffer = Decoder.FallbackBuffer
        End If
    End If
    
    CharsUBound = UBound(Chars)
    
    If FallbackBuffer.Fallback(BytesUnknown, ByteIndex) Then
        Dim Ch As Integer

        If CharIndex + FallbackBuffer.Remaining - 1 > CharsUBound Then _
            ThrowDecoderSmallConversionBuffer

        Do While FallbackBuffer.Remaining > 0
            Ch = FallbackBuffer.GetNextChar
            Chars(CharIndex) = Ch
            CharIndex = CharIndex + 1
        Loop
    End If
    
    InsertDecoderFallback = CharIndex
End Function

Private Sub ThrowDecoderSmallConversionBuffer()
    Throw Cor.NewArgumentException(Environment.GetResourceString(Argument_EncodingConversionOverflowChars, EncodingName, TypeName(DecoderFallback)), "Chars")
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   Serialization
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub Class_ReadProperties(PropBag As PropertyBag)
    With PropBag
        mIsBigEndian = .ReadProperty(IsBigEndianProp)
        mEmitBOM = .ReadProperty(EmitBOMProp)
        mCodePage = .ReadProperty(CodePageProp)
        mIsReadOnly = .ReadProperty(IsReadOnlyProp)
        Set mDecoderFallback = .ReadProperty(DecoderFallbackProp, Statics.DecoderFallback.ExceptionFallback)
        Set mEncoderFallback = .ReadProperty(EncoderFallbackProp, Statics.EncoderFallback.ExceptionFallback)
    End With
End Sub

Private Sub Class_WriteProperties(PropBag As PropertyBag)
    With PropBag
        .WriteProperty IsBigEndianProp, mIsBigEndian
        .WriteProperty EmitBOMProp, mEmitBOM
        .WriteProperty CodePageProp, mCodePage
        .WriteProperty IsReadOnlyProp, mIsReadOnly
        
        If Not mDecoderFallback.Equals(Statics.DecoderFallback.ExceptionFallback) Then
            .WriteProperty DecoderFallbackProp, mDecoderFallback
        End If
        
        If Not mEncoderFallback.Equals(Statics.EncoderFallback.ExceptionFallback) Then
            .WriteProperty EncoderFallbackProp, mEncoderFallback
        End If
    End With
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   ICloneable
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function ICloneable_Clone() As Object
    Set ICloneable_Clone = Clone
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   IObject Interface
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function IObject_Equals(Value As Variant) As Boolean
    IObject_Equals = Equals(Value)
End Function

Private Function IObject_GetHashCode() As Long
    IObject_GetHashCode = GetHashCode
End Function

Private Function IObject_ToString() As String
    IObject_ToString = ToString
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'   Encoding Interface
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Property Get Encoding_IsReadOnly() As Boolean
    Encoding_IsReadOnly = IsReadOnly
End Property

Private Function Encoding_Clone() As Encoding
    Set Encoding_Clone = Clone
End Function

Private Property Set Encoding_DecoderFallback(ByVal Value As DecoderFallback)
    Set DecoderFallback = Value
End Property

Private Property Get Encoding_DecoderFallback() As DecoderFallback
    Set Encoding_DecoderFallback = DecoderFallback
End Property

Private Property Set Encoding_EncoderFallback(ByVal Value As EncoderFallback)
    Set EncoderFallback = Value
End Property

Private Property Get Encoding_EncoderFallback() As EncoderFallback
    Set Encoding_EncoderFallback = EncoderFallback
End Property

Private Property Get Encoding_BodyName() As String
    Encoding_BodyName = BodyName
End Property

Private Property Get Encoding_CodePage() As Long
    Encoding_CodePage = CodePage
End Property

Private Property Get Encoding_EncodingName() As String
    Encoding_EncodingName = EncodingName
End Property

Private Function Encoding_Equals(Value As Variant) As Boolean
    Encoding_Equals = Equals(Value)
End Function

Private Function Encoding_GetByteCount(Chars As Variant, Optional Index As Variant, Optional Count As Variant) As Long
    Encoding_GetByteCount = GetByteCount(Chars, Index, Count)
End Function

Private Function Encoding_GetBytes(Chars As Variant, Optional Index As Variant, Optional Count As Variant) As Byte()
    Encoding_GetBytes = GetBytes(Chars, Index, Count)
End Function

Private Function Encoding_GetBytesEx(Chars As Variant, ByVal CharIndex As Long, ByVal CharCount As Long, Bytes() As Byte, ByVal ByteIndex As Long) As Long
    Encoding_GetBytesEx = GetBytesEx(Chars, CharIndex, CharCount, Bytes, ByteIndex)
End Function

Private Function Encoding_GetCharCount(Bytes() As Byte, Optional Index As Variant, Optional Count As Variant) As Long
    Encoding_GetCharCount = GetCharCount(Bytes, Index, Count)
End Function

Private Function Encoding_GetChars(Bytes() As Byte, Optional Index As Variant, Optional Count As Variant) As Integer()
    Encoding_GetChars = GetChars(Bytes, Index, Count)
End Function

Private Function Encoding_GetCharsEx(Bytes() As Byte, ByVal ByteIndex As Long, ByVal ByteCount As Long, Chars() As Integer, ByVal CharIndex As Long) As Long
    Encoding_GetCharsEx = GetCharsEx(Bytes, ByteIndex, ByteCount, Chars, CharIndex)
End Function

Private Function Encoding_GetDecoder() As Decoder
    Set Encoding_GetDecoder = GetDecoder
End Function

Private Function Encoding_GetEncoder() As Encoder
    Set Encoding_GetEncoder = GetEncoder
End Function

Private Function Encoding_GetHashCode() As Long
    Encoding_GetHashCode = GetHashCode
End Function

Private Function Encoding_GetMaxByteCount(ByVal CharCount As Long) As Long
    Encoding_GetMaxByteCount = GetMaxByteCount(CharCount)
End Function

Private Function Encoding_GetMaxCharCount(ByVal ByteCount As Long) As Long
    Encoding_GetMaxCharCount = GetMaxCharCount(ByteCount)
End Function

Private Function Encoding_GetPreamble() As Byte()
    Encoding_GetPreamble = GetPreamble
End Function

Private Function Encoding_GetString(Bytes() As Byte, Optional Index As Variant, Optional Count As Variant) As String
    Encoding_GetString = GetString(Bytes, Index, Count)
End Function

Private Property Get Encoding_HeaderName() As String
    Encoding_HeaderName = HeaderName
End Property

Private Property Get Encoding_IsBrowserDisplay() As Boolean
    Encoding_IsBrowserDisplay = IsBrowserDisplay
End Property

Private Property Get Encoding_IsBrowserSave() As Boolean
    Encoding_IsBrowserSave = IsBrowserSave
End Property

Private Property Get Encoding_IsMailNewsDisplay() As Boolean
    Encoding_IsMailNewsDisplay = IsMailNewsDisplay
End Property

Private Property Get Encoding_IsMailNewsSave() As Boolean
    Encoding_IsMailNewsSave = IsMailNewsSave
End Property

Private Function Encoding_ToString() As String
    Encoding_ToString = ToString
End Function

Private Property Get Encoding_WebName() As String
    Encoding_WebName = WebName
End Property

Private Property Get Encoding_WindowsCodePage() As Long
    Encoding_WindowsCodePage = WindowsCodePage
End Property

Private Property Get Encoding_IsSingleByte() As Boolean
    Encoding_IsSingleByte = IsSingleByte
End Property


